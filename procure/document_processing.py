import pdfplumber
import pytesseract
from PIL import Image
from io import BytesIO
from django.utils import timezone
import json
from django.conf import settings
from google import genai
from google.genai import types

def get_gemini_client():
    """Lazy-load Gemini client to avoid initialization errors"""
    return genai.Client(api_key=settings.GEMINI_API_KEY)

def extract_text_from_pdf(fileobj):
    text = ''
    try:
        with pdfplumber.open(fileobj) as pdf:
            for page in pdf.pages:
                page_text = page.extract_text()
                if page_text:
                    text += '\n' + page_text
                else:
                    # OCR fallback per page
                    try:
                        img = page.to_image(resolution=300)
                        pil_img = Image.open(BytesIO(img.original))
                        text += "\n" + pytesseract.image_to_string(pil_img)
                    except:
                        pass
    except:
        # Not a PDF, maybe an image file
        try:
            pil = Image.open(fileobj)
            text = pytesseract.image_to_string(pil)
        except:
            text = ''
    return text

from procure.models import PurchaseOrder, ReceiptValidation


from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
from django.core.files.base import ContentFile

def generate_po_for_request(pr, generated_by=None):
    vendor = pr.vendor or 'Unknown vendor'
    extracted = {}
    if pr.proforma:
        try:
            txt = extract_text_from_pdf(pr.proforma.path)
            extracted['raw_text'] = txt[:4000]
        except Exception:
            extracted['raw_text'] = ''
    
    content = {
        'vendor': vendor,
        'items': [
            {'name': it.name, 'qty': it.qty, 'unit_price': str(it.unit_price)} for it in pr.items.all()
        ],
        'total': str(pr.amount),
        'extracted': extracted,
    }

    # Generate PDF
    buffer = BytesIO()
    p = canvas.Canvas(buffer, pagesize=letter)
    width, height = letter

    # Header
    p.setFont("Helvetica-Bold", 20)
    p.drawString(50, height - 50, f"Purchase Order #{pr.id}")
    
    p.setFont("Helvetica", 12)
    p.drawString(50, height - 80, f"Date: {timezone.now().strftime('%Y-%m-%d')}")
    p.drawString(50, height - 100, f"Vendor: {vendor}")
    p.drawString(50, height - 120, f"Request Title: {pr.title}")
    p.drawString(50, height - 140, f"Total Amount: ${pr.amount}")

    # Items Table Header
    y = height - 180
    p.setFont("Helvetica-Bold", 12)
    p.drawString(50, y, "Item")
    p.drawString(300, y, "Qty")
    p.drawString(400, y, "Unit Price")
    p.drawString(500, y, "Total")
    
    # Items Rows
    y -= 20
    p.setFont("Helvetica", 12)
    for item in pr.items.all():
        p.drawString(50, y, item.name[:40])
        p.drawString(300, y, str(item.qty))
        p.drawString(400, y, f"${item.unit_price}")
        p.drawString(500, y, f"${item.total_price}")
        y -= 20

    # Footer
    p.setFont("Helvetica-Oblique", 10)
    p.drawString(50, 50, "Generated by Procure-to-Pay System")
    
    p.showPage()
    p.save()

    pdf_content = buffer.getvalue()
    buffer.close()

    # Create PO object
    po = PurchaseOrder.objects.create(
        request=pr, 
        generated_by=generated_by, 
        content=content
    )
    
    # Save PDF file (this uploads to Cloudinary)
    filename = f"PO_{pr.id}_{timezone.now().strftime('%Y%m%d%H%M%S')}.pdf"
    po.file.save(filename, ContentFile(pdf_content))
    
    return po

async def get_gemini_response(
    user_message: str,
    file_content: str = None,
    file_name: str = None,
    include_thoughts: bool = True,  # thinking enabled
) -> "AsyncGenerator[str, None]":
    """
    Streams response from Gemini without external search tools.
    """
    try:
        # Thinking config only, no search
        config = types.GenerateContentConfig(
            thinking_config=types.ThinkingConfig(include_thoughts=include_thoughts)
            if include_thoughts
            else None,
        )

        contents = []
        if file_content and file_name:
            file_part = types.Part.from_text(
                text=f"File: {file_name}\n\n{file_content}"
            )
            contents.append(file_part)
            contents.append(f"Based on the file above, {user_message}")
        else:
            contents.append(user_message)

        # Hard-coded model
        client = get_gemini_client()
        response_stream = client.models.generate_content_stream(
            model="gemini-2.5-flash",
            contents=contents,
            config=config,
        )

        for chunk in response_stream:
            for part in chunk.candidates[0].content.parts:
                if getattr(part, "thought", False):
                    continue
                if part.text:
                    yield part.text

    except Exception as e:
        import traceback
        yield f"\n[ERROR: {e}]\n{traceback.format_exc()}\n"

async def compare_receipt_with_gemini(po_data, receipt_text):
    """
    Compares a PO with a receipt using Gemini.
    Uses detailed instructions, thinking enabled, no external search.
    """
    prompt = f"""
You are a receipt validation assistant. Compare the following Purchase Order (PO) details with the text extracted from a receipt.

Purchase Order Details:
Vendor: {po_data['vendor']}
Total Amount: {po_data['total']}
Items:
{json.dumps(po_data['items'], indent=2)}

Receipt Text:
{receipt_text}

Task:
1. Check if the vendor name matches (fuzzy match allowed).
2. Check if the total amount matches.
3. Check if the items match (names, quantities, prices).

Return a JSON object with the following structure:
{{
    "is_valid": boolean,
    "discrepancies": [list of strings describing any mismatches]
}}
If everything matches, "is_valid" should be true and "discrepancies" should be empty.

IMPORTANT: Return ONLY the JSON object, no other text.
"""

    full_response = ""
    # Include receipt_text directly in the prompt, don't pass as file_content
    async for chunk in get_gemini_response(prompt, include_thoughts=False):
        full_response += chunk

    try:
        cleaned_response = full_response.replace('```json', '').replace('```', '').strip()
        result = json.loads(cleaned_response)
        return result
    except Exception as e:
        return {
            "is_valid": False,
            "discrepancies": [f"Failed to parse JSON: {str(e)}", f"Raw response: {full_response}"]
        }


def validate_receipt_against_po(pr):
    """
    Comprehensive validation of receipt against Purchase Order using Gemini.
    """
    po = getattr(pr, 'po_obj', None)
    if not po:
        return {'ok': False, 'reason': 'No PO available'}
    
    # Extract text from receipt
    receipt_text = ''
    try:
        # Open the file from storage (works with both local and cloud storage)
        with pr.receipt.open('rb') as receipt_file:
            receipt_text = extract_text_from_pdf(receipt_file)
    except Exception as e:
        return {'ok': False, 'reason': f'Failed to extract text from receipt: {str(e)}'}
    
    # Construct PO data for AI
    po_data = {
        'vendor': pr.vendor or 'Unknown',
        'total': str(pr.amount),
        'items': [
            {
                'name': item.name, 
                'qty': item.qty, 
                'unit_price': str(item.unit_price), 
                'total': str(item.total_price)
            } 
            for item in pr.items.all()
        ]
    }
    
    
    from asgiref.sync import async_to_sync
    ai_result = async_to_sync(compare_receipt_with_gemini)(po_data, receipt_text)
    
    is_valid = ai_result.get('is_valid', False)
    discrepancies = ai_result.get('discrepancies', [])
    
    # Prepare result dict
    result = {
        'ok': is_valid,
        'discrepancies': discrepancies
    }
    
    # Save validation results using update_or_create to avoid IntegrityError
    ReceiptValidation.objects.update_or_create(
        request=pr,
        defaults={
            'validated_at': timezone.now(),
            'validation_result': result,
            'discrepancies': discrepancies,
            'is_valid': is_valid
        }
    )
    
    return result

def validate_receipt_against_po_with_text(pr, receipt_text):
    """
    Validation using pre-extracted receipt text (more efficient for Celery tasks).
    This is called from the Celery task with the text already extracted.
    """
    po = getattr(pr, 'po_obj', None)
    if not po:
        return {'ok': False, 'reason': 'No PO available'}
    
    # Construct PO data for AI
    po_data = {
        'vendor': pr.vendor or 'Unknown',
        'total': str(pr.amount),
        'items': [
            {
                'name': item.name, 
                'qty': item.qty, 
                'unit_price': str(item.unit_price), 
                'total': str(item.total_price)
            } 
            for item in pr.items.all()
        ]
    }
    
    # Perform AI comparison
    from asgiref.sync import async_to_sync
    ai_result = async_to_sync(compare_receipt_with_gemini)(po_data, receipt_text)
    
    is_valid = ai_result.get('is_valid', False)
    discrepancies = ai_result.get('discrepancies', [])
    
    # Prepare result dict
    result = {
        'ok': is_valid,
        'discrepancies': discrepancies
    }
    
    # Save validation results
    ReceiptValidation.objects.update_or_create(
        request=pr,
        defaults={
            'validated_at': timezone.now(),
            'validation_result': result,
            'discrepancies': discrepancies,
            'is_valid': is_valid
        }
    )
    
    return result
